# Лабораторна робота № 8. Вступ до документації коду

## 1 Вимоги

### 1.1 Розробник

* Коваленко Єва;
* студентка групи КІТ-121д;
* 18.12.2021.

### 1.2 Загальне завдання
Варіант 22. Заповнити масив із заданої кількості елементів простими числами заданого діапазону, що не повторюються. Розмір вихідного масиву задати наперед відомим значенням, що може будуть більшим аніж результуюча кількість отриманих елементів. Якщо масив більше, ніж кількість унікальних значень - невикористовані комірки замінити нулями. 
## 2 Хід роботи

### 2.1 Код програми
Створимо необхідні для програми змінні - масив, два числа для діапозону, лічильник заповнених елементів в масиві та булеву змінну для перевірки, що знайдене число нам підходить(воно просте і ще не було використано в масиві). 
```c
	iint N = 10; // переменная для кол-ва элементов в массиве
	int massive[N];
	int d1, d2;
	int counter = 0;
	d1 = 5;
	d2 = 20;
	bool tru;
	}
```
Створимо чотири цикла. Перший перебирає елементи масиву. Другий перебирає числа в заданому діапозоні, при кожному новому використанні змінює значення змінної tru. 
Наступний цикл перевіряє, чи є вибране число простим. Якщо число ділиться націло на 2 або більше число, що менше за нього, значення змінної tru змінюється, а цикл припиняється. Після віходу з цього цикла наступна відносна конструкція перевіряє значення tru, яке не повинно було змінитися, якщо вибране число просте. Наступний цикл перевіряє наявність також самого числа в елементах масиву. Якщо воно є, змінна tru змінюється. Потім знов перевіряєм значення tru, і якщо воно підходить нам по всім параметрам, ми записуєм це число в один із елементів масиву. При цьому ми додаємо до лічильника одиницю(це кількість записаних значень), а цикл припиняється.
```c
	for(int i = 0; i <= N; i++){ // номер числа массива	 
	 for(int k = d1; k <= d2; k++){ // число из диапозона
	   tru = true;
	  for(int l = 2; l < k; l++){   // проверка числа на простоту 
		float rem = k % l; 
		if(rem == 0){ // если число поделилось нацело, меняется значение для проверки и выходит из цикла
		   tru = false;
		   break;
			}}
	 if (tru == true)
	 	for (int i2 = 0; i2 <= N; i2++) { // проверка что данного числа еще не было в массиве 
	 	if (massive[i2] == k) 
	 		tru = false;
	 	}
	 if (tru == true){ // заполнение элемент массива простым числом из диапозона
	 	massive[i] = k;
		counter++; // счетчик инициализированых элементов
		break;
		}}
	}

```
Останній цикл записує у невикористанні комірки масиву нулі.
```c
 for(int i = counter; i < N; i++) // инициализация пустых элементов массива нулями по счетчику заполненных элем.
		massive[i] = 0;
```

## 3 Висновок
Під час цієї роботи було розроблено програму, у якій використовують масив.

